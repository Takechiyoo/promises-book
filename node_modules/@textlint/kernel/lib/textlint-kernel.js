// MIT Â© 2017 azu
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TextlintKernel = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _sourceCode = require("./core/source-code");

var _sourceCode2 = _interopRequireDefault(_sourceCode);

var _fixerProcessor = require("./fixer/fixer-processor");

var _fixerProcessor2 = _interopRequireDefault(_fixerProcessor);

var _linterProcessor = require("./linter/linter-processor");

var _linterProcessor2 = _interopRequireDefault(_linterProcessor);

var _MessageProcessManager = require("./messages/MessageProcessManager");

var _MessageProcessManager2 = _interopRequireDefault(_MessageProcessManager);

var _filterIgnoredProcess = require("./messages/filter-ignored-process");

var _filterIgnoredProcess2 = _interopRequireDefault(_filterIgnoredProcess);

var _filterDuplicatedProcess = require("./messages/filter-duplicated-process");

var _filterDuplicatedProcess2 = _interopRequireDefault(_filterDuplicatedProcess);

var _filterSeverityProcess = require("./messages/filter-severity-process");

var _filterSeverityProcess2 = _interopRequireDefault(_filterSeverityProcess);

var _sortMessagesProcess = require("./messages/sort-messages-process");

var _sortMessagesProcess2 = _interopRequireDefault(_sortMessagesProcess);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require("assert");
var Ajv = require("ajv");
var ajv = new Ajv();
var TextlintKernelOptionsSchema = require("./TextlintKernelOptions.json");
// sequence

// parallel

// message process manager


/**
 * @param {TextlintKernelPlugin[]} plugins
 * @param {string} ext
 * @returns {TextlintKernelPlugin|undefined} PluginConstructor
 */
function findPluginWithExt() {
    var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var ext = arguments[1];

    var matchPlugins = plugins.filter(function (kernelPlugin) {
        var plugin = kernelPlugin.plugin;
        // static availableExtensions() method
        assert.ok(typeof plugin.Processor.availableExtensions === "function", "Processor(" + plugin.Processor.name + " should have availableExtensions()");
        var extList = plugin.Processor.availableExtensions();
        return extList.some(function (targetExt) {
            return targetExt === ext || "." + targetExt === ext;
        });
    });
    if (matchPlugins.length === 0) {
        return;
    }
    return matchPlugins[0];
}
/**
 * add fileName to trailing of error message
 * @param {string|undefined} fileName
 * @param {string} message
 * @returns {string}
 */
function addingAtFileNameToError(fileName, message) {
    if (!fileName) {
        return message;
    }
    return message + "\nat " + fileName;
}

/**
 *
 * Pass
 *
 * - config
 * - plugins
 * - rules
 * - filterRules
 * - messageProcessor
 *
 */

var TextlintKernel = exports.TextlintKernel = function () {
    /**
     * TODO: THIS
     * @param config
     */
    function TextlintKernel() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, TextlintKernel);

        // this.config often is undefined.
        this.config = config;
        // Initialize Message Processor
        // Now, It it built-in process only
        this.messageProcessManager = new _MessageProcessManager2.default();
        // filter `shouldIgnore()` results
        this.messageProcessManager.add(_filterIgnoredProcess2.default);
        // filter duplicated messages
        this.messageProcessManager.add(_filterDuplicatedProcess2.default);
        // filter by severity
        this.messageProcessManager.add((0, _filterSeverityProcess2.default)(this.config));
        this.messageProcessManager.add(_sortMessagesProcess2.default);
    }

    /**
     * lint text by registered rules.
     * The result contains target filePath and error messages.
     * @param {string} text
     * @param {Object} options linting options
     * @returns {Promise.<TextLintResult>}
     */


    _createClass(TextlintKernel, [{
        key: "lintText",
        value: function lintText(text, options) {
            var valid = ajv.validate(TextlintKernelOptionsSchema, options);
            if (!valid) {
                return Promise.reject(new Error("options is invalid. Please check document.\nErrors: " + JSON.stringify(ajv.errors, null, 4) + "\nActual: " + JSON.stringify(options, null, 4) + "\n"));
            }
            var ext = options.ext;
            var plugin = findPluginWithExt(options.plugins, ext);
            assert(plugin !== undefined && plugin.plugin !== undefined, "Not found available plugin for " + ext);
            var Processor = plugin.plugin.Processor;
            assert(Processor !== undefined, "This plugin has not Processor: " + plugin);
            var processor = new Processor(this.config);
            return this._parallelProcess({
                processor: processor, text: text, options: options
            });
        }

        /**
         * fix texts and return fix result object
         * @param {string} text
         * @param {Object} options lint options
         * @returns {Promise.<TextLintFixResult>}
         */

    }, {
        key: "fixText",
        value: function fixText(text, options) {
            var valid = ajv.validate(TextlintKernelOptionsSchema, options);
            if (!valid) {
                return Promise.reject(new Error("options is invalid. Please check document.\nErrors: " + JSON.stringify(ajv.errors, null, 4) + "\nActual: " + JSON.stringify(options, null, 4) + "\n"));
            }
            var ext = options.ext;
            var plugin = findPluginWithExt(options.plugins, ext);
            assert(plugin !== undefined, "Not found available plugin for " + ext);
            var Processor = plugin.plugin.Processor;
            assert(Processor !== undefined, "This plugin has not Processor: " + plugin);
            var processor = new Processor(this.config);
            return this._sequenceProcess({
                processor: processor,
                text: text,
                options: options
            });
        }

        /**
         * process text in parallel for Rules and return {Promise.<TextLintResult>}
         * In other word, parallel flow process.
         * @param {*} processor
         * @param {string} text
         * @param {Object} options
         * @returns {Promise.<TextLintResult>}
         * @private
         */

    }, {
        key: "_parallelProcess",
        value: function _parallelProcess(_ref) {
            var processor = _ref.processor,
                text = _ref.text,
                options = _ref.options;
            var ext = options.ext,
                filePath = options.filePath,
                rules = options.rules,
                filterRules = options.filterRules,
                configBaseDir = options.configBaseDir;

            var _processor$processor = processor.processor(ext),
                preProcess = _processor$processor.preProcess,
                postProcess = _processor$processor.postProcess;

            assert(typeof preProcess === "function" && typeof postProcess === "function", "processor should implement {preProcess, postProcess}");
            var ast = preProcess(text, filePath);
            var sourceCode = new _sourceCode2.default({
                text: text,
                ast: ast,
                ext: ext,
                filePath: filePath
            });
            var linterProcessor = new _linterProcessor2.default(processor, this.messageProcessManager);
            return linterProcessor.process({
                config: this.config,
                rules: rules,
                filterRules: filterRules,
                sourceCode: sourceCode,
                configBaseDir: configBaseDir
            }).catch(function (error) {
                error.message = addingAtFileNameToError(filePath, error.message);
                return Promise.reject(error);
            });
        }

        /**
         * process text in series for Rules and return {Promise.<TextLintFixResult>}
         * In other word, sequence flow process.
         * @param {*} processor
         * @param {string} text
         * @param {TextlintKernelOptions} options
         * @returns {Promise.<TextLintFixResult>}
         * @private
         */

    }, {
        key: "_sequenceProcess",
        value: function _sequenceProcess(_ref2) {
            var processor = _ref2.processor,
                text = _ref2.text,
                options = _ref2.options;
            var ext = options.ext,
                filePath = options.filePath,
                rules = options.rules,
                filterRules = options.filterRules,
                configBaseDir = options.configBaseDir;

            assert(processor, "processor is not found for " + ext);

            var _processor$processor2 = processor.processor(ext),
                preProcess = _processor$processor2.preProcess,
                postProcess = _processor$processor2.postProcess;

            assert(typeof preProcess === "function" && typeof postProcess === "function", "processor should implement {preProcess, postProcess}");
            var ast = preProcess(text, filePath);
            var sourceCode = new _sourceCode2.default({
                text: text,
                ast: ast,
                ext: ext,
                filePath: filePath
            });
            var fixerProcessor = new _fixerProcessor2.default(processor, this.messageProcessManager);
            return fixerProcessor.process({
                config: this.config,
                rules: rules,
                filterRules: filterRules,
                sourceCode: sourceCode,
                configBaseDir: configBaseDir
            }).catch(function (error) {
                error.message = addingAtFileNameToError(filePath, error.message);
                return Promise.reject(error);
            });
        }
    }]);

    return TextlintKernel;
}();
//# sourceMappingURL=textlint-kernel.js.map