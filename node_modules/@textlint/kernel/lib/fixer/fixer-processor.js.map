{"version":3,"sources":["../../src/fixer/fixer-processor.js"],"names":["debug","require","FixerProcessor","processor","messageProcessManager","config","configBaseDir","rules","filterRules","sourceCode","Array","isArray","ext","preProcess","postProcess","resultFilePath","filePath","applyingMessages","remainingMessages","originalMessages","fixerProcessList","filter","rule","map","fixerRule","sourceText","newSourceCode","text","ast","task","process","then","result","messages","applied","applyFixes","prototype","push","apply","fixed","output","promiseTask","reduce","promise","fixerProcess","Promise","resolve","length"],"mappings":"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","file":"fixer-processor.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst debug = require(\"debug\")(\"textlint:fixer-processor\");\nimport assert from \"assert\";\nimport FixerTask from \"../task/fixer-task\";\nimport SourceCode from \"../core/source-code\";\nimport SourceCodeFixer from \"../fixer/source-code-fixer\";\nimport TaskRunner from \"../task/task-runner\";\nimport { hasFixer } from \"../core/rule-creator-helper\";\n\nexport default class FixerProcessor {\n    /**\n     * @param {Processor} processor\n     * @param {MessageProcessManager} messageProcessManager\n     */\n    constructor(processor, messageProcessManager) {\n        this.processor = processor;\n        this.messageProcessManager = messageProcessManager;\n    }\n\n    /**\n     * Run fixer process\n     * @param {Config} config\n     * @param {string} [configBaseDir]\n     * @param {TextlintKernelRule[]} [rules]\n     * @param {TextlintKernelFilterRule[]} [filterRules]\n     * @param {SourceCode} sourceCode\n     * @returns {Promise.<TextLintFixResult>}\n     */\n    process({ config, configBaseDir, rules = [], filterRules = [], sourceCode }) {\n        assert(config && Array.isArray(rules) && Array.isArray(filterRules) && sourceCode);\n        const { preProcess, postProcess } = this.processor.processor(sourceCode.ext);\n        // messages\n        let resultFilePath = sourceCode.filePath;\n        // applied fixing messages\n        // Revert = Sequentially apply applied message to applied output\n        // SourceCodeFixer.sequentiallyApplyFixes(fixedOutput, result.applyingMessages);\n        const applyingMessages = [];\n        // not applied fixing messages\n        const remainingMessages = [];\n        // original means original for applyingMessages and remainingMessages\n        // pre-applyingMessages + remainingMessages\n        const originalMessages = [];\n        const fixerProcessList = rules.filter((rule) => {\n            return hasFixer(rule.rule);\n        }).map((fixerRule) => {\n            return (sourceText) => {\n                // create new SourceCode object\n                const newSourceCode = new SourceCode({\n                    text: sourceText,\n                    ast: preProcess(sourceText),\n                    filePath: resultFilePath,\n                    ext: sourceCode.ext\n                });\n                // create new Task\n                const task = new FixerTask({\n                    config,\n                    fixerRule,\n                    filterRules,\n                    sourceCode: newSourceCode,\n                    configBaseDir\n                });\n\n                return TaskRunner.process(task).then(messages => {\n                    const result = postProcess(messages, sourceCode.filePath);\n                    result.messages = this.messageProcessManager.process(result.messages);\n                    if (result.filePath == null) {\n                        result.filePath = `<Unkown${sourceCode.ext}>`;\n                    }\n                    resultFilePath = result.filePath;\n                    const applied = SourceCodeFixer.applyFixes(newSourceCode, result.messages);\n                    // add messages\n                    Array.prototype.push.apply(applyingMessages, applied.applyingMessages);\n                    Array.prototype.push.apply(remainingMessages, applied.remainingMessages);\n                    Array.prototype.push.apply(originalMessages, applied.messages);\n                    // if not fixed, still use current sourceText\n                    if (!applied.fixed) {\n                        return sourceText;\n                    }\n                    // if fixed, use fixed text at next\n                    return applied.output;\n                });\n            };\n        });\n\n        const promiseTask = fixerProcessList.reduce((promise, fixerProcess) => {\n            return promise.then((sourceText) => {\n                return fixerProcess(sourceText);\n            });\n        }, Promise.resolve(sourceCode.text));\n\n        return promiseTask.then(output => {\n            debug(`Finish Processing: ${resultFilePath}`);\n            debug(`applyingMessages: ${applyingMessages.length}`);\n            debug(`remainingMessages: ${remainingMessages.length}`);\n            return {\n                filePath: resultFilePath,\n                output,\n                messages: originalMessages,\n                applyingMessages,\n                remainingMessages\n            };\n        });\n    }\n}\n"]}