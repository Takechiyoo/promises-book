{"version":3,"sources":["../src/index.js"],"names":[],"mappings":";;;;;;;;;;;;AACA;;AACA;;;;;;;;;;;;;;;;;IAGqB,Y;;;AACnB,0BAAgC;AAAA,QAApB,WAAoB,yDAAN,IAAM;;AAAA;;AAAA;;AAE9B,QAAI,eAAe,CAAnB,EAAsB;AACpB,YAAK,cAAL,CAAoB,WAApB;AACD;AAJ6B;AAK/B;;;;;;;;;;;;;qCAS0B;AAAA,UAAZ,GAAY,yDAAN,IAAM;;AACzB,UAAI,OAAO,CAAX,EAAc;AACZ,aAAK,OAAL,GAAe,0CAAgB,GAAhB,CAAf;AACD,OAFD,MAEO;AACL,aAAK,OAAL,GAAe,IAAf;AACD;AACD,aAAO,IAAP;AACD;;;;;;;;;;;;;oCAUe,Q,EAAU,I,EAAM;AAC9B,UAAI;AACF,YAAI,KAAK,OAAT,EAAkB;AAChB,iBAAO,KAAK,OAAL,CAAa;AAAA,mBAAM,6CAAY,IAAZ,EAAN;AAAA,WAAb,CAAP;AACD;AACD,eAAO,2BAAgB,6CAAY,IAAZ,EAAhB,CAAP;AACD,OALD,CAKE,OAAO,KAAP,EAAc;AACd,eAAO,0BAAe,KAAf,CAAP;AACD;AACF;;;;;;;;;;;;;;iCAWY,K,EAAgB;AAAA;;AAAA,wCAAN,IAAM;AAAN,YAAM;AAAA;;AAC3B,UAAM,WAAW,EAAjB;;AAEA,WAAK,SAAL,CAAe,KAAf,EAAsB,OAAtB,CAA8B,oBAAY;AACxC,iBAAS,IAAT,CAAc,OAAK,eAAL,CAAqB,QAArB,EAA+B,IAA/B,CAAd;AACD,OAFD;;AAIA,aAAO,uBAAY,QAAZ,CAAP;AACD;;;;;;;;;;;;;+BAUU,K,EAAgB;AAAA;;AAAA,yCAAN,IAAM;AAAN,YAAM;AAAA;;AACzB,aAAO,KAAK,SAAL,CAAe,KAAf,EAAsB,MAAtB,CACL,UAAC,OAAD,EAAU,QAAV;AAAA,eAAuB,QAAQ,IAAR,CAAa,UAAC,MAAD;AAAA,iBAClC,OAAK,eAAL,CAAqB,QAArB,EAA+B,IAA/B,EAAqC,IAArC,CACE,UAAC,KAAD,EAAW;AACT,mBAAO,IAAP,CAAY,KAAZ;AACA,mBAAO,MAAP;AACD,WAJH,CADkC;AAAA,SAAb,CAAvB;AAAA,OADK,EASL,2BAAgB,EAAhB,CATK,CAAP;AAWD;;;;;;;;;;;;;+BAUU,K,EAAgB;AAAA,yCAAN,IAAM;AAAN,YAAM;AAAA;;AACzB,aAAO,KAAK,aAAL,CAAmB,KAAnB,EAA0B,IAA1B,CAAP;AACD;;;;;;;;;;;;;oCAUe,K,EAAgB;AAAA,yCAAN,IAAM;AAAN,YAAM;AAAA;;AAC9B,aAAO,KAAK,aAAL,CAAmB,KAAnB,EAA0B,IAA1B,EAAgC,IAAhC,CAAP;AACD;;;;;;;;;;;;;;kCAWa,K,EAAO,I,EAAuB;AAAA;;AAAA,UAAjB,OAAiB,yDAAP,KAAO;;AAC1C,UAAM,YAAY,UAAU,KAAK,SAAL,CAAe,KAAf,EAAsB,OAAtB,EAAV,GAA4C,KAAK,SAAL,CAAe,KAAf,CAA9D;AACA,aAAO,UAAU,MAAV,CACL,UAAC,OAAD,EAAU,QAAV;AAAA,eAAuB,QAAQ,IAAR,CAAa,UAAC,QAAD,EAAc;AAChD,cAAM,cAAc,oBAAoB,KAApB,GAA4B,QAA5B,GAAuC,CAAC,QAAD,CAA3D;AACA,iBAAO,OAAK,eAAL,CAAqB,QAArB,EAA+B,WAA/B,CAAP;AACD,SAHsB,CAAvB;AAAA,OADK,EAKL,2BAAgB,IAAhB,CALK,CAAP;AAOD;;;;;;;;;;;;;;yBAWI,K,EAAO,Q,EAAU;AAAA;;AACpB,UAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAClC,cAAM,IAAI,SAAJ,CAAc,6BAAd,CAAN;AACD;;AAED,UAAI,QAAQ,KAAZ;AACA,UAAM,eAAe,SAAf,YAAe,GAAa;AAChC,eAAK,cAAL,CAAoB,KAApB,EAA2B,YAA3B;;AAEA,YAAI,UAAU,KAAd,EAAqB;AACnB,kBAAQ,IAAR;AACA,iBAAO,oCAAP;AACD;AACD,eAAO,SAAP;AACD,OARD;;;AAWA,mBAAa,QAAb,GAAwB,QAAxB;AACA,WAAK,EAAL,CAAQ,KAAR,EAAe,YAAf;;AAEA,aAAO,IAAP;AACD;;;;;;;;;;;;;;8BAWS,K,EAAO,Q,EAAwB;AAAA;;AAAA,UAAd,IAAc,yDAAP,KAAO;;AACvC,UAAM,cAAc,SAAd,WAAc,GAAM;AACxB,eAAK,cAAL,CAAoB,KAApB,EAA2B,QAA3B;AACD,OAFD;;AAIA,UAAI,IAAJ,EAAU;AACR,aAAK,IAAL,CAAU,KAAV,EAAiB,QAAjB;AACD,OAFD,MAEO;AACL,aAAK,EAAL,CAAQ,KAAR,EAAe,QAAf;AACD;;AAED,aAAO,WAAP;AACD;;;;;;kBArLkB,Y","file":"index.js","sourcesContent":["// dependencies\nimport { EventEmitter } from 'events';\nimport throat from 'throat';\n\n// @class AsyncEmitter\nexport default class AsyncEmitter extends EventEmitter {\n  constructor(concurrency = null) {\n    super();\n    if (concurrency >= 1) {\n      this.setConcurrency(concurrency);\n    }\n  }\n\n  /**\n  * reset concurrency of instance\n  *\n  * @method setConcurrency\n  * @param {number} [max=null] - a number of maximum concurrency\n  * @returns {asyncEmitter} this\n  */\n  setConcurrency(max = null) {\n    if (max >= 1) {\n      this.manager = throat(Promise)(max);\n    } else {\n      this.manager = null;\n    }\n    return this;\n  }\n\n  /**\n  * run the listener as Promise\n  *\n  * @method executeListener\n  * @param {function} listener - a code block\n  * @param {any[]} args - a event arguments\n  * @returns {promise} - the return value or exception\n  */\n  executeListener(listener, args) {\n    try {\n      if (this.manager) {\n        return this.manager(() => listener(...args));\n      }\n      return Promise.resolve(listener(...args));\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n\n  /**\n  * run the listeners in parallel\n  *\n  * @method emitParallel\n  * @alias emit\n  * @param {string} event - a event name\n  * @param {any} arguments - a arguments pass to listeners\n  * @returns {promise<any>} - the return value of listeners\n  */\n  emitParallel(event, ...args) {\n    const promises = [];\n\n    this.listeners(event).forEach(listener => {\n      promises.push(this.executeListener(listener, args));\n    });\n\n    return Promise.all(promises);\n  }\n\n  /**\n  * run the listeners in serial\n  *\n  * @method emitSerial\n  * @param {string} event - a event name\n  * @param {any} arguments - a arguments pass to listeners\n  * @returns {promise<any>} - the return value of listeners\n  */\n  emitSerial(event, ...args) {\n    return this.listeners(event).reduce(\n      (promise, listener) => promise.then((values) =>\n        this.executeListener(listener, args).then(\n          (value) => {\n            values.push(value);\n            return values;\n          },\n        )\n      ),\n      Promise.resolve([]),\n    );\n  }\n\n  /**\n  * run the listeners in serial using previous listener return value\n  *\n  * @method emitReduce\n  * @param {string} event - a event name\n  * @param {any} arguments - a arguments pass to listeners\n  * @returns {promise<any>} - the return value of listeners\n  */\n  emitReduce(event, ...args) {\n    return this.emitReduceRun(event, args);\n  }\n\n  /**\n  * run the listeners in serial and in inverse using previous listener return value\n  *\n  * @method emitReduceRight\n  * @param {string} event - a event name\n  * @param {any} arguments - a arguments pass to listeners\n  * @returns {promise<any>} - the return value of listeners\n  */\n  emitReduceRight(event, ...args) {\n    return this.emitReduceRun(event, args, true);\n  }\n\n  /**\n  * emitReduce/emitReduceRight common processing\n  *\n  * @method emitReduceRun\n  * @param {string} event - a event name\n  * @param {any[]} args - a arguments pass to first listener\n  * @param {boolean} [inverse=false] - if true, execute listner in inverse\n  * @returns {any[]} values - the return value of last listener\n  */\n  emitReduceRun(event, args, inverse = false) {\n    const listeners = inverse ? this.listeners(event).reverse() : this.listeners(event);\n    return listeners.reduce(\n      (promise, listener) => promise.then((prevArgs) => {\n        const currentArgs = prevArgs instanceof Array ? prevArgs : [prevArgs];\n        return this.executeListener(listener, currentArgs);\n      }),\n      Promise.resolve(args),\n    );\n  }\n\n  /**\n  * emit a 'removeListener' event iff the listener was removed\n  * (redefine for inherited method doesn't work)\n  *\n  * @method once\n  * @param {string} event - a event name\n  * @param {function} listener - a listener function\n  * @returns {asyncEmitter} this\n  */\n  once(event, listener) {\n    if (typeof listener !== 'function') {\n      throw new TypeError('listener must be a function');\n    }\n\n    let fired = false;\n    const onceListener = (...args) => {\n      this.removeListener(event, onceListener);\n\n      if (fired === false) {\n        fired = true;\n        return listener(...args);\n      }\n      return undefined;\n    };\n\n    // https://github.com/nodejs/node/blob/v4.1.2/lib/events.js#L286\n    onceListener.listener = listener;\n    this.on(event, onceListener);\n\n    return this;\n  }\n\n  /**\n  * register an event listener, returns the remove function\n  *\n  * @method subscribe\n  * @param {string} event - a event name\n  * @param {function} listener - a listener function\n  * @param {boolean} [once=false] - if true, listener is call only once\n  * @returns {function} unsubscribe - the remove function of listener\n  */\n  subscribe(event, listener, once = false) {\n    const unsubscribe = () => {\n      this.removeListener(event, listener);\n    };\n\n    if (once) {\n      this.once(event, listener);\n    } else {\n      this.on(event, listener);\n    }\n\n    return unsubscribe;\n  }\n}\n"]}