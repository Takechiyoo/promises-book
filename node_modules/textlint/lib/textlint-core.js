// LICENSE : MIT
"use strict";
/*
 textlint-core.js is a class
 textlint.js is a singleton object that is instance of textlint-core.js.
 */

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _kernel = require("@textlint/kernel");

var _fsPromise = require("./util/fs-promise");

var _textlintPluginMarkdown = require("textlint-plugin-markdown");

var _textlintPluginMarkdown2 = _interopRequireDefault(_textlintPluginMarkdown);

var _textlintPluginText = require("textlint-plugin-text");

var _textlintPluginText2 = _interopRequireDefault(_textlintPluginText);

var _ruleCreatorSet = require("./core/rule-creator-set");

var _ruleCreatorSet2 = _interopRequireDefault(_ruleCreatorSet);

var _pluginCreatorSet = require("./core/plugin-creator-set");

var _pluginCreatorSet2 = _interopRequireDefault(_pluginCreatorSet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var path = require("path");
var ObjectAssign = require("object-assign");

/**
 * @class {TextlintCore}
 */
var TextlintCore = function () {
    function TextlintCore() {
        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, TextlintCore);

        // this.config often is undefined.
        this.config = config;
        // Markdown and Text is enabled by default
        // Markdown and Text are for backward compatibility.
        this.defaultPlugins = {
            markdown: _textlintPluginMarkdown2.default,
            text: _textlintPluginText2.default
        };
        // TODO: remove `config`
        // https://github.com/textlint/textlint/issues/296
        this.kernel = new _kernel.TextlintKernel(config);
        this.pluginCreatorSet = new _pluginCreatorSet2.default(this.defaultPlugins);
        this.ruleCreatorSet = new _ruleCreatorSet2.default();
        this.filterRuleCreatorSet = new _ruleCreatorSet2.default();
    }

    /**
     * Use setupPlugins insteadof it.
     *
     * ````
     * textlint.setupPlugins({
     *   yourPluginName: yourPlugin
     * });
     * ````
     *
     * @param {*} Processor
     * @deprecated
     *
     * It will be removed
     */


    _createClass(TextlintCore, [{
        key: "addProcessor",
        value: function addProcessor(Processor) {
            this.pluginCreatorSet = new _pluginCreatorSet2.default(ObjectAssign({}, this.defaultPlugins, _defineProperty({}, Processor.name + "@deprecated", {
                Processor: Processor
            })));
        }

        /**
         * register Processors
         * @param {Object} plugins
         */

    }, {
        key: "setupPlugins",
        value: function setupPlugins() {
            var plugins = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            this.pluginCreatorSet = new _pluginCreatorSet2.default(ObjectAssign({}, this.defaultPlugins, plugins));
        }

        /**
         * Register rules and rulesConfig.
         * if want to release rules, please call {@link resetRules}.
         * @param {object} rules rule objects array
         * @param {object} [rulesConfig] ruleConfig is object
         */

    }, {
        key: "setupRules",
        value: function setupRules() {
            var rules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var rulesConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            this.ruleCreatorSet = new _ruleCreatorSet2.default(rules, rulesConfig);
        }

        /**
         * Register filterRules and filterRulesConfig.
         * if want to release rules, please call {@link resetRules}.
         * @param {object} rules rule objects array
         * @param {object} [rulesConfig] ruleConfig is object
         */

    }, {
        key: "setupFilterRules",
        value: function setupFilterRules() {
            var rules = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var rulesConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            this.filterRuleCreatorSet = new _ruleCreatorSet2.default(rules, rulesConfig);
        }

        /**
         * Remove all registered rule and clear messages.
         */

    }, {
        key: "resetRules",
        value: function resetRules() {
            this.pluginCreatorSet = new _pluginCreatorSet2.default(this.defaultPlugins);
            this.ruleCreatorSet = new _ruleCreatorSet2.default();
            this.filterRuleCreatorSet = new _ruleCreatorSet2.default();
        }

        /**
         * lint text by registered rules.
         * The result contains target filePath and error messages.
         * @param {string} text
         * @param {string} ext ext is extension. default: .txt
         * @returns {Promise.<TextLintResult>}
         */

    }, {
        key: "lintText",
        value: function lintText(text) {
            var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ".txt";

            var options = this._mergeSetupOptions({
                ext: ext
            });
            return this.kernel.lintText(text, options);
        }

        /**
         * lint markdown text by registered rules.
         * The result contains target filePath and error messages.
         * @param {string} text markdown format text
         * @returns {Promise.<TextLintResult>}
         */

    }, {
        key: "lintMarkdown",
        value: function lintMarkdown(text) {
            var ext = ".md";
            var options = this._mergeSetupOptions({
                ext: ext
            });
            return this.kernel.lintText(text, options);
        }

        /**
         * lint file and return result object
         * @param {string} filePath
         * @returns {Promise.<TextLintResult>} result
         */

    }, {
        key: "lintFile",
        value: function lintFile(filePath) {
            var _this = this;

            var absoluteFilePath = path.resolve(process.cwd(), filePath);
            var ext = path.extname(absoluteFilePath);
            var options = this._mergeSetupOptions({
                ext: ext,
                filePath: absoluteFilePath
            });
            return (0, _fsPromise.readFile)(absoluteFilePath).then(function (text) {
                return _this.kernel.lintText(text, options);
            });
        }

        /**
         * fix file and return fix result object
         * @param {string} filePath
         * @returns {Promise.<TextLintFixResult>}
         */

    }, {
        key: "fixFile",
        value: function fixFile(filePath) {
            var _this2 = this;

            var absoluteFilePath = path.resolve(process.cwd(), filePath);
            var ext = path.extname(absoluteFilePath);
            var options = this._mergeSetupOptions({
                ext: ext,
                filePath: absoluteFilePath
            });
            return (0, _fsPromise.readFile)(absoluteFilePath).then(function (text) {
                return _this2.kernel.fixText(text, options);
            });
        }

        /**
         * fix texts and return fix result object
         * @param {string} text
         * @param {string} ext
         * @returns {Promise.<TextLintFixResult>}
         */

    }, {
        key: "fixText",
        value: function fixText(text) {
            var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ".txt";

            var options = this._mergeSetupOptions({
                ext: ext
            });
            return this.kernel.fixText(text, options);
        }

        /**
         * @private
         */

    }, {
        key: "_mergeSetupOptions",
        value: function _mergeSetupOptions(options) {
            var configFileBaseDir = typeof this.config.configFile === "string" ? path.dirname(this.config.configFile) : undefined;
            return ObjectAssign({}, options, {
                configBaseDir: configFileBaseDir,
                plugins: this.pluginCreatorSet.toKernelPluginsFormat(),
                rules: this.ruleCreatorSet.toKernelRulesFormat(),
                filterRules: this.filterRuleCreatorSet.toKernelRulesFormat()
            });
        }
    }]);

    return TextlintCore;
}();

exports.default = TextlintCore;
module.exports = exports["default"];
//# sourceMappingURL=textlint-core.js.map